<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>Display API documentation</title>
<meta name="description" content="Author: John Burns …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>Display</code></h1>
</header>
<section id="section-intro">
<p>Author: John Burns</p>
<p>Last Modified: 5/25/2021</p>
<p>OSU Email Address: burnsjo@oregonstate.edu</p>
<p>Course Number ECE 342</p>
<p>Project: LED Visualizer Group 2</p>
<p>Due Date: 5/28/2021</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Author: John Burns\n
Last Modified: 5/25/2021\n
OSU Email Address: burnsjo@oregonstate.edu\n
Course Number ECE 342\n
Project: LED Visualizer Group 2\n
Due Date: 5/28/2021
&#34;&#34;&#34;

from tkinter import *
from Animation import Animation
from Colors import *
import time
import sys

class Display:
    &#34;&#34;&#34;
    Class made for displaying animations on a window.\n
        Animates at the speed of the animation.
        Play button and back button is disabled while animation is playing.
        Pause button pauses the animation in frame (togglable for easy quick clicking, disabled whne nothing is playing)
        Stop button enables play button and back button as well as restarts the animation (disabled when nothing is playing).\n
    parameters: window, a window for displaying a canvas on (Toplevel)\n
                animation, the animation to display (Animation)
                backBtnSettings, a way to get back to another window (txt, command)
    &#34;&#34;&#34;
    def __init__(self, window: Toplevel, animation: Animation, backBtnSettings: list):
        #Save window for later.
        self.window = window
        self.window.protocol(&#34;WM_DELETE_WINDOW&#34;, sys.exit)

        #Is the program to be played, or are we paused?
        self.play = BooleanVar(value = True)

        #Make a frame for the buttons.
        self.frame = Frame(self.window)
        self.frame.pack(anchor = W)

        #Keep track of time.
        self.t = None

        #Save settings for later.
        self.backBtnSettings = backBtnSettings
        #Create the buttons.
        self.createBtns(self.frame)

        #Create a canvas for the display.
        self.canvas = Canvas(self.window, width = 500, height = 700, bg=&#34;#000000&#34;)
        self.canvas.pack()

        #Save animation features for later.
        self.animation = animation
        self.speed = int(1000/self.animation.getSpeed())

        #Provide a way to count within the class.
        self.counter = 0

    def createBtns(self, frame: Frame):
        &#34;&#34;&#34;
        Creates the buttons used for controlling the animation.\n
            One button for starting the animation.
            One button for going back to the previous window.
            One button for pausing the animation.
            One button for stopping the animation.\n
        parameters: frame, the frame to create the buttons on (Frame).
        &#34;&#34;&#34;
        #Create a fresh button for a nice layout.
        #Create the play button.
        self.playButton = Button(frame, text = &#34;Play Animation&#34;, command = self.playAnimation)
        self.playButton.pack(side = LEFT)

        #Create the back button. Account for the user not having a command (no back button functionality)
        if len(self.backBtnSettings) == 1:
            self.backBtnSettings.append(None)
        self.backButton = Button(frame, text = self.backBtnSettings[0], command = self.backBtnSettings[1])
        self.backButton.pack(side = LEFT)
        
        #Create a togglable pause button.
        self.pauseButton = Checkbutton(frame, text=&#34;Pause Animation&#34;, onvalue=False, offvalue=True, variable=self.play, command = self.pauseBehavior, activeforeground=&#34;black&#34;)
        self.pauseButton.pack(side = LEFT)

        #Create a stop button.
        self.stopButton = Button(frame, text = &#34;Stop Animation&#34;, command = self.stopAnimation)
        self.stopButton.pack(side = LEFT)

        #Disable the pause and stop button (nothing is playing right now).
        self.pauseButton[&#39;state&#39;] = DISABLED
        self.stopButton[&#39;state&#39;] = DISABLED

    def pauseBehavior(self):
        &#34;&#34;&#34;
        Define the behavior of clicking pause.
        &#34;&#34;&#34;
        #If we are playing, pause otherwise do nothing.
        if self.play.get():
            #If the animation is done, reenable the play and back button.
            if self.counter == self.animation.getNumFrames():
                #Clear animation if on last frame.
                self.resetCanvas()
            #If the play button is distabled, the animation must be paused.
            elif self.playButton[&#39;state&#39;] == DISABLED:
                #Continue animation.
                self.drawCircles()

    def createCircle(self, x: int, y: int, r: int, **kwargs):
        &#34;&#34;&#34;
        Helpfull function to create a circle with the oval function.\n
        parameters: x, the x coordinate (int)\n
                    y, the y coordinate (int)
                    r, the radius (int)
                    kwargs, extra arguments for create oval.
        &#34;&#34;&#34;
        self.canvas.create_oval(x-r, y-r, x+r, y+r, **kwargs)

    def resetCanvas(self):
        &#34;&#34;&#34;
        Resets the canvas.
        &#34;&#34;&#34;
        # If playing go ahead, otherwise return (prevents infinite recursion).
        if self.play.get():
            #clear the canvas.
            self.canvas.destroy()

            #Make a new canvas.
            self.canvas = Canvas(self.window, width = 500, height = 700, bg=&#34;#000000&#34;)
            self.canvas.pack()

            #Draw the next frame.
            self.window.after(0, self.drawCircles)

            #If the animation is done, reenable the play and back button.
            #   Disable the pause button and stop button.
            if self.counter == self.animation.getNumFrames():
                self.playButton[&#39;state&#39;] = NORMAL
                self.backButton[&#39;state&#39;] = NORMAL
                self.pauseButton[&#39;state&#39;] = DISABLED
                self.stopButton[&#39;state&#39;] = DISABLED
    
    def drawCircles(self):
        &#34;&#34;&#34;
        Draw a frames of the animation.
        &#34;&#34;&#34;
        #only draw a frame when the time has elapsed.
        if  not (not self.play.get() and self.counter != self.animation.getNumFrames()) \
                and self.counter &lt; self.animation.getNumFrames() \
                and int((time.perf_counter() - self.t) * 1000) &gt;= self.speed:
            #Record time.
            self.t = time.perf_counter()

            #Get the matrix.
            matrix = self.animation.getFrame(self.counter)
            for x in range(matrix.getxlen()):
                for z in range(matrix.getzlen()):
                    for y in range(matrix.getylen()):
                        #Create a 3D animation. Going back into the top right.
                        self.createCircle(x*100+y*10+25, 700-z*100-y*10-25, 5, fill = &#34;#&#34;+str(getHex(matrix.getVal(x, matrix.getylen() - 1 - y, z))))

            #Keep track of frame.
            self.counter += 1

            #Wait the preset amount of time and clear canvas for next animation.
            self.window.after(self.speed, self.resetCanvas)

    def playAnimation(self):
        &#34;&#34;&#34;
        Rest the counter every time an animation is played.
        &#34;&#34;&#34;
        #Reset the animation.
        self.counter = 0
        
        #Disable the play and back button, but activate the pause and stop button.
        self.playButton[&#39;state&#39;] = DISABLED
        self.backButton[&#39;state&#39;] = DISABLED
        self.pauseButton[&#39;state&#39;] = NORMAL
        self.stopButton[&#39;state&#39;] = NORMAL
        
        #Set time to the time that would have the program start.
        self.t = ((time.perf_counter() * 1000) - self.speed)/1000

        #Show the animation.
        self.drawCircles()
    
    def stopAnimation(self):
        &#34;&#34;&#34;
        Stops the animation. This enables the play and stop button. It also enables the play\n
            button. If paused, it resets that as well.
        &#34;&#34;&#34;
        #Put the counter at the end, so no currently waiting calls will run.
        self.counter = self.animation.getNumFrames()

        #If there is stuff disabled, the animation must be paused.
        # Otherwise it isn&#39;t. Prevents the play button from getting changed just by the stop button.
        if self.playButton[&#39;state&#39;] == DISABLED:
            self.play.set(True)

            self.playButton[&#39;state&#39;] = NORMAL
            self.backButton[&#39;state&#39;] = NORMAL
            self.resetCanvas()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="Display.Display"><code class="flex name class">
<span>class <span class="ident">Display</span></span>
<span>(</span><span>window: tkinter.Toplevel, animation: <a title="Animation.Animation" href="Animation.html#Animation.Animation">Animation</a>, backBtnSettings: list)</span>
</code></dt>
<dd>
<div class="desc"><p>Class made for displaying animations on a window.</p>
<pre><code>Animates at the speed of the animation.
Play button and back button is disabled while animation is playing.
Pause button pauses the animation in frame (togglable for easy quick clicking, disabled whne nothing is playing)
Stop button enables play button and back button as well as restarts the animation (disabled when nothing is playing).
</code></pre>
<p>parameters: window, a window for displaying a canvas on (Toplevel)</p>
<pre><code>        animation, the animation to display (Animation)
        backBtnSettings, a way to get back to another window (txt, command)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Display:
    &#34;&#34;&#34;
    Class made for displaying animations on a window.\n
        Animates at the speed of the animation.
        Play button and back button is disabled while animation is playing.
        Pause button pauses the animation in frame (togglable for easy quick clicking, disabled whne nothing is playing)
        Stop button enables play button and back button as well as restarts the animation (disabled when nothing is playing).\n
    parameters: window, a window for displaying a canvas on (Toplevel)\n
                animation, the animation to display (Animation)
                backBtnSettings, a way to get back to another window (txt, command)
    &#34;&#34;&#34;
    def __init__(self, window: Toplevel, animation: Animation, backBtnSettings: list):
        #Save window for later.
        self.window = window
        self.window.protocol(&#34;WM_DELETE_WINDOW&#34;, sys.exit)

        #Is the program to be played, or are we paused?
        self.play = BooleanVar(value = True)

        #Make a frame for the buttons.
        self.frame = Frame(self.window)
        self.frame.pack(anchor = W)

        #Keep track of time.
        self.t = None

        #Save settings for later.
        self.backBtnSettings = backBtnSettings
        #Create the buttons.
        self.createBtns(self.frame)

        #Create a canvas for the display.
        self.canvas = Canvas(self.window, width = 500, height = 700, bg=&#34;#000000&#34;)
        self.canvas.pack()

        #Save animation features for later.
        self.animation = animation
        self.speed = int(1000/self.animation.getSpeed())

        #Provide a way to count within the class.
        self.counter = 0

    def createBtns(self, frame: Frame):
        &#34;&#34;&#34;
        Creates the buttons used for controlling the animation.\n
            One button for starting the animation.
            One button for going back to the previous window.
            One button for pausing the animation.
            One button for stopping the animation.\n
        parameters: frame, the frame to create the buttons on (Frame).
        &#34;&#34;&#34;
        #Create a fresh button for a nice layout.
        #Create the play button.
        self.playButton = Button(frame, text = &#34;Play Animation&#34;, command = self.playAnimation)
        self.playButton.pack(side = LEFT)

        #Create the back button. Account for the user not having a command (no back button functionality)
        if len(self.backBtnSettings) == 1:
            self.backBtnSettings.append(None)
        self.backButton = Button(frame, text = self.backBtnSettings[0], command = self.backBtnSettings[1])
        self.backButton.pack(side = LEFT)
        
        #Create a togglable pause button.
        self.pauseButton = Checkbutton(frame, text=&#34;Pause Animation&#34;, onvalue=False, offvalue=True, variable=self.play, command = self.pauseBehavior, activeforeground=&#34;black&#34;)
        self.pauseButton.pack(side = LEFT)

        #Create a stop button.
        self.stopButton = Button(frame, text = &#34;Stop Animation&#34;, command = self.stopAnimation)
        self.stopButton.pack(side = LEFT)

        #Disable the pause and stop button (nothing is playing right now).
        self.pauseButton[&#39;state&#39;] = DISABLED
        self.stopButton[&#39;state&#39;] = DISABLED

    def pauseBehavior(self):
        &#34;&#34;&#34;
        Define the behavior of clicking pause.
        &#34;&#34;&#34;
        #If we are playing, pause otherwise do nothing.
        if self.play.get():
            #If the animation is done, reenable the play and back button.
            if self.counter == self.animation.getNumFrames():
                #Clear animation if on last frame.
                self.resetCanvas()
            #If the play button is distabled, the animation must be paused.
            elif self.playButton[&#39;state&#39;] == DISABLED:
                #Continue animation.
                self.drawCircles()

    def createCircle(self, x: int, y: int, r: int, **kwargs):
        &#34;&#34;&#34;
        Helpfull function to create a circle with the oval function.\n
        parameters: x, the x coordinate (int)\n
                    y, the y coordinate (int)
                    r, the radius (int)
                    kwargs, extra arguments for create oval.
        &#34;&#34;&#34;
        self.canvas.create_oval(x-r, y-r, x+r, y+r, **kwargs)

    def resetCanvas(self):
        &#34;&#34;&#34;
        Resets the canvas.
        &#34;&#34;&#34;
        # If playing go ahead, otherwise return (prevents infinite recursion).
        if self.play.get():
            #clear the canvas.
            self.canvas.destroy()

            #Make a new canvas.
            self.canvas = Canvas(self.window, width = 500, height = 700, bg=&#34;#000000&#34;)
            self.canvas.pack()

            #Draw the next frame.
            self.window.after(0, self.drawCircles)

            #If the animation is done, reenable the play and back button.
            #   Disable the pause button and stop button.
            if self.counter == self.animation.getNumFrames():
                self.playButton[&#39;state&#39;] = NORMAL
                self.backButton[&#39;state&#39;] = NORMAL
                self.pauseButton[&#39;state&#39;] = DISABLED
                self.stopButton[&#39;state&#39;] = DISABLED
    
    def drawCircles(self):
        &#34;&#34;&#34;
        Draw a frames of the animation.
        &#34;&#34;&#34;
        #only draw a frame when the time has elapsed.
        if  not (not self.play.get() and self.counter != self.animation.getNumFrames()) \
                and self.counter &lt; self.animation.getNumFrames() \
                and int((time.perf_counter() - self.t) * 1000) &gt;= self.speed:
            #Record time.
            self.t = time.perf_counter()

            #Get the matrix.
            matrix = self.animation.getFrame(self.counter)
            for x in range(matrix.getxlen()):
                for z in range(matrix.getzlen()):
                    for y in range(matrix.getylen()):
                        #Create a 3D animation. Going back into the top right.
                        self.createCircle(x*100+y*10+25, 700-z*100-y*10-25, 5, fill = &#34;#&#34;+str(getHex(matrix.getVal(x, matrix.getylen() - 1 - y, z))))

            #Keep track of frame.
            self.counter += 1

            #Wait the preset amount of time and clear canvas for next animation.
            self.window.after(self.speed, self.resetCanvas)

    def playAnimation(self):
        &#34;&#34;&#34;
        Rest the counter every time an animation is played.
        &#34;&#34;&#34;
        #Reset the animation.
        self.counter = 0
        
        #Disable the play and back button, but activate the pause and stop button.
        self.playButton[&#39;state&#39;] = DISABLED
        self.backButton[&#39;state&#39;] = DISABLED
        self.pauseButton[&#39;state&#39;] = NORMAL
        self.stopButton[&#39;state&#39;] = NORMAL
        
        #Set time to the time that would have the program start.
        self.t = ((time.perf_counter() * 1000) - self.speed)/1000

        #Show the animation.
        self.drawCircles()
    
    def stopAnimation(self):
        &#34;&#34;&#34;
        Stops the animation. This enables the play and stop button. It also enables the play\n
            button. If paused, it resets that as well.
        &#34;&#34;&#34;
        #Put the counter at the end, so no currently waiting calls will run.
        self.counter = self.animation.getNumFrames()

        #If there is stuff disabled, the animation must be paused.
        # Otherwise it isn&#39;t. Prevents the play button from getting changed just by the stop button.
        if self.playButton[&#39;state&#39;] == DISABLED:
            self.play.set(True)

            self.playButton[&#39;state&#39;] = NORMAL
            self.backButton[&#39;state&#39;] = NORMAL
            self.resetCanvas()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="Display.Display.createBtns"><code class="name flex">
<span>def <span class="ident">createBtns</span></span>(<span>self, frame: tkinter.Frame)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates the buttons used for controlling the animation.</p>
<pre><code>One button for starting the animation.
One button for going back to the previous window.
One button for pausing the animation.
One button for stopping the animation.
</code></pre>
<p>parameters: frame, the frame to create the buttons on (Frame).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def createBtns(self, frame: Frame):
    &#34;&#34;&#34;
    Creates the buttons used for controlling the animation.\n
        One button for starting the animation.
        One button for going back to the previous window.
        One button for pausing the animation.
        One button for stopping the animation.\n
    parameters: frame, the frame to create the buttons on (Frame).
    &#34;&#34;&#34;
    #Create a fresh button for a nice layout.
    #Create the play button.
    self.playButton = Button(frame, text = &#34;Play Animation&#34;, command = self.playAnimation)
    self.playButton.pack(side = LEFT)

    #Create the back button. Account for the user not having a command (no back button functionality)
    if len(self.backBtnSettings) == 1:
        self.backBtnSettings.append(None)
    self.backButton = Button(frame, text = self.backBtnSettings[0], command = self.backBtnSettings[1])
    self.backButton.pack(side = LEFT)
    
    #Create a togglable pause button.
    self.pauseButton = Checkbutton(frame, text=&#34;Pause Animation&#34;, onvalue=False, offvalue=True, variable=self.play, command = self.pauseBehavior, activeforeground=&#34;black&#34;)
    self.pauseButton.pack(side = LEFT)

    #Create a stop button.
    self.stopButton = Button(frame, text = &#34;Stop Animation&#34;, command = self.stopAnimation)
    self.stopButton.pack(side = LEFT)

    #Disable the pause and stop button (nothing is playing right now).
    self.pauseButton[&#39;state&#39;] = DISABLED
    self.stopButton[&#39;state&#39;] = DISABLED</code></pre>
</details>
</dd>
<dt id="Display.Display.createCircle"><code class="name flex">
<span>def <span class="ident">createCircle</span></span>(<span>self, x: int, y: int, r: int, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Helpfull function to create a circle with the oval function.</p>
<p>parameters: x, the x coordinate (int)</p>
<pre><code>        y, the y coordinate (int)
        r, the radius (int)
        kwargs, extra arguments for create oval.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def createCircle(self, x: int, y: int, r: int, **kwargs):
    &#34;&#34;&#34;
    Helpfull function to create a circle with the oval function.\n
    parameters: x, the x coordinate (int)\n
                y, the y coordinate (int)
                r, the radius (int)
                kwargs, extra arguments for create oval.
    &#34;&#34;&#34;
    self.canvas.create_oval(x-r, y-r, x+r, y+r, **kwargs)</code></pre>
</details>
</dd>
<dt id="Display.Display.drawCircles"><code class="name flex">
<span>def <span class="ident">drawCircles</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Draw a frames of the animation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def drawCircles(self):
    &#34;&#34;&#34;
    Draw a frames of the animation.
    &#34;&#34;&#34;
    #only draw a frame when the time has elapsed.
    if  not (not self.play.get() and self.counter != self.animation.getNumFrames()) \
            and self.counter &lt; self.animation.getNumFrames() \
            and int((time.perf_counter() - self.t) * 1000) &gt;= self.speed:
        #Record time.
        self.t = time.perf_counter()

        #Get the matrix.
        matrix = self.animation.getFrame(self.counter)
        for x in range(matrix.getxlen()):
            for z in range(matrix.getzlen()):
                for y in range(matrix.getylen()):
                    #Create a 3D animation. Going back into the top right.
                    self.createCircle(x*100+y*10+25, 700-z*100-y*10-25, 5, fill = &#34;#&#34;+str(getHex(matrix.getVal(x, matrix.getylen() - 1 - y, z))))

        #Keep track of frame.
        self.counter += 1

        #Wait the preset amount of time and clear canvas for next animation.
        self.window.after(self.speed, self.resetCanvas)</code></pre>
</details>
</dd>
<dt id="Display.Display.pauseBehavior"><code class="name flex">
<span>def <span class="ident">pauseBehavior</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Define the behavior of clicking pause.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pauseBehavior(self):
    &#34;&#34;&#34;
    Define the behavior of clicking pause.
    &#34;&#34;&#34;
    #If we are playing, pause otherwise do nothing.
    if self.play.get():
        #If the animation is done, reenable the play and back button.
        if self.counter == self.animation.getNumFrames():
            #Clear animation if on last frame.
            self.resetCanvas()
        #If the play button is distabled, the animation must be paused.
        elif self.playButton[&#39;state&#39;] == DISABLED:
            #Continue animation.
            self.drawCircles()</code></pre>
</details>
</dd>
<dt id="Display.Display.playAnimation"><code class="name flex">
<span>def <span class="ident">playAnimation</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Rest the counter every time an animation is played.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def playAnimation(self):
    &#34;&#34;&#34;
    Rest the counter every time an animation is played.
    &#34;&#34;&#34;
    #Reset the animation.
    self.counter = 0
    
    #Disable the play and back button, but activate the pause and stop button.
    self.playButton[&#39;state&#39;] = DISABLED
    self.backButton[&#39;state&#39;] = DISABLED
    self.pauseButton[&#39;state&#39;] = NORMAL
    self.stopButton[&#39;state&#39;] = NORMAL
    
    #Set time to the time that would have the program start.
    self.t = ((time.perf_counter() * 1000) - self.speed)/1000

    #Show the animation.
    self.drawCircles()</code></pre>
</details>
</dd>
<dt id="Display.Display.resetCanvas"><code class="name flex">
<span>def <span class="ident">resetCanvas</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Resets the canvas.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resetCanvas(self):
    &#34;&#34;&#34;
    Resets the canvas.
    &#34;&#34;&#34;
    # If playing go ahead, otherwise return (prevents infinite recursion).
    if self.play.get():
        #clear the canvas.
        self.canvas.destroy()

        #Make a new canvas.
        self.canvas = Canvas(self.window, width = 500, height = 700, bg=&#34;#000000&#34;)
        self.canvas.pack()

        #Draw the next frame.
        self.window.after(0, self.drawCircles)

        #If the animation is done, reenable the play and back button.
        #   Disable the pause button and stop button.
        if self.counter == self.animation.getNumFrames():
            self.playButton[&#39;state&#39;] = NORMAL
            self.backButton[&#39;state&#39;] = NORMAL
            self.pauseButton[&#39;state&#39;] = DISABLED
            self.stopButton[&#39;state&#39;] = DISABLED</code></pre>
</details>
</dd>
<dt id="Display.Display.stopAnimation"><code class="name flex">
<span>def <span class="ident">stopAnimation</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Stops the animation. This enables the play and stop button. It also enables the play</p>
<pre><code>button. If paused, it resets that as well.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stopAnimation(self):
    &#34;&#34;&#34;
    Stops the animation. This enables the play and stop button. It also enables the play\n
        button. If paused, it resets that as well.
    &#34;&#34;&#34;
    #Put the counter at the end, so no currently waiting calls will run.
    self.counter = self.animation.getNumFrames()

    #If there is stuff disabled, the animation must be paused.
    # Otherwise it isn&#39;t. Prevents the play button from getting changed just by the stop button.
    if self.playButton[&#39;state&#39;] == DISABLED:
        self.play.set(True)

        self.playButton[&#39;state&#39;] = NORMAL
        self.backButton[&#39;state&#39;] = NORMAL
        self.resetCanvas()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="Display.Display" href="#Display.Display">Display</a></code></h4>
<ul class="two-column">
<li><code><a title="Display.Display.createBtns" href="#Display.Display.createBtns">createBtns</a></code></li>
<li><code><a title="Display.Display.createCircle" href="#Display.Display.createCircle">createCircle</a></code></li>
<li><code><a title="Display.Display.drawCircles" href="#Display.Display.drawCircles">drawCircles</a></code></li>
<li><code><a title="Display.Display.pauseBehavior" href="#Display.Display.pauseBehavior">pauseBehavior</a></code></li>
<li><code><a title="Display.Display.playAnimation" href="#Display.Display.playAnimation">playAnimation</a></code></li>
<li><code><a title="Display.Display.resetCanvas" href="#Display.Display.resetCanvas">resetCanvas</a></code></li>
<li><code><a title="Display.Display.stopAnimation" href="#Display.Display.stopAnimation">stopAnimation</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>